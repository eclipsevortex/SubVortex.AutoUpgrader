name: Docker Build & Push All Services

on:
  push:
    tags:
      - "v*.*.*"
      - "v*.*.*-*"
  release:
    types: [published]

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v3

      - name: üß† Discover components and services
        id: set-matrix
        run: |
          # Customize these lists as needed
          EXCLUDED_COMPONENTS=(core validator)
          EXCLUDED_SERVICES=()

          should_exclude() {
            local item=$1
            shift
            local list=("$@")
            for ex in "${list[@]}"; do
              if [[ "$item" == "$ex" ]]; then
                return 0
              fi
            done
            return 1
          }

          mkdir -p .build/tmp_matrix
          echo '{ "include": [' > .build/tmp_matrix/matrix.json
          FIRST=true

          for comp in subvortex/*; do
            [ -d "$comp" ] || continue
            comp_name=$(basename "$comp")

            # üî• Skip excluded components
            if should_exclude "$comp_name" "${EXCLUDED_COMPONENTS[@]}"; then
              echo "‚è≠Ô∏è Skipping excluded component: $comp_name"
              continue
            fi

            for service in "$comp"/*; do
              [ -d "$service" ] || continue
              service_name=$(basename "$service")

              # üî• Skip excluded services
              if should_exclude "$service_name" "${EXCLUDED_SERVICES[@]}"; then
                echo "‚è≠Ô∏è Skipping excluded service: $service_name"
                continue
              fi

              # ‚úÖ Include only if it has a pyproject or version.py
              if [[ -f "$service/pyproject.toml" || -f "$service/version.py" ]]; then
                if [ "$FIRST" = true ]; then
                  FIRST=false
                else
                  echo "," >> .build/tmp_matrix/matrix.json
                fi
                echo "  { \"component\": \"$comp_name\", \"service\": \"$service_name\" }" >> .build/tmp_matrix/matrix.json
              fi
            done
          done

          echo "] }" >> .build/tmp_matrix/matrix.json

          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          cat .build/tmp_matrix/matrix.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "üîç Final matrix ready."

  wheel-builder:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
    steps:
      - name: üßæ Checkout
        uses: actions/checkout@v3

      - name: üõ† Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: üõ† Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host

      - name: üîê Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üß† Generate build tag from hash
        id: meta
        run: |
          HASH=$(sha256sum subvortex/core/Dockerfile.builder | cut -d ' ' -f1)
          echo "tag=subvortex/subvortex-wheel-builder:3.11-$HASH" >> $GITHUB_OUTPUT

      - name: üêã Build & push wheel-builder (only if not exists)
        run: |
          if docker pull ${{ steps.meta.outputs.tag }} >/dev/null 2>&1; then
            echo "‚úÖ Image already exists: ${{ steps.meta.outputs.tag }}"
          else
            echo "üöÄ Building wheel-builder image"
            docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --tag ${{ steps.meta.outputs.tag }} \
              --file subvortex/core/Dockerfile.builder \
              --push \
              .
          fi

  build:
    needs: [discover, wheel-builder]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include: ${{ fromJson(needs.discover.outputs.matrix).include }}

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v3

      - name: üõ† Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: üß± Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: üîê Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üß† Determine tag and floating tags
        id: taginfo
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "version_tag=$TAG" >> $GITHUB_OUTPUT

          FLOATING_TAGS="dev"
          if [[ "$TAG" == *-rc* ]]; then
            FLOATING_TAGS="dev stable"
          elif [[ "$TAG" != *-* ]]; then
            FLOATING_TAGS="dev stable latest"
          fi
          echo "floating_tags=$FLOATING_TAGS" >> $GITHUB_OUTPUT

      - name: üöÄ Build and push version-tagged image (on tag push only)
        if: startsWith(github.ref, 'refs/tags/') && github.event_name == 'push'
        run: |
          COMP=${{ matrix.component }}
          SERVICE=${{ matrix.service }}
          IMAGE="subvortex/subvortex-$COMP-$SERVICE"
          WHEEL_IMAGE="${{ needs.wheel-builder.outputs.tag }}"
          RAW_VERSION_TAG="${{ steps.taginfo.outputs.version_tag }}"
          VERSION_TAG="${RAW_VERSION_TAG#v}"
          DOCKERFILE="subvortex/$COMP/$SERVICE/Dockerfile"

          echo "üöÄ Building image $IMAGE:$VERSION_TAG"

          docker buildx build \
            --squash \
            --platform linux/amd64,linux/arm64 \
            --build-context wheelbuilder=docker-image://$WHEEL_IMAGE \
            --build-arg VERSION=$VERSION_TAG \
            --build-arg COMPONENT_VERSION=$VERSION_TAG \
            --cache-from=type=gha,scope=wheels_${COMP}_${SERVICE}_${ARCH} \
            --cache-to=type=gha,mode=max,scope=wheels_${COMP}_${SERVICE}_${ARCH} \
            --tag $IMAGE:$VERSION_TAG \
            --file $DOCKERFILE \
            --push \
            .

  release:
    needs: [discover]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include: ${{ fromJson(needs.discover.outputs.matrix).include }}

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v3

      - name: üõ† Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: üß± Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: üîê Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üß† Determine tag and floating tags
        id: taginfo
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "version_tag=$TAG" >> $GITHUB_OUTPUT

          FLOATING_TAGS="dev"
          if [[ "$TAG" == *-rc* ]]; then
            FLOATING_TAGS="dev stable"
          elif [[ "$TAG" != *-* ]]; then
            FLOATING_TAGS="dev stable latest"
          fi
          echo "floating_tags=$FLOATING_TAGS" >> $GITHUB_OUTPUT

      - name: üöÄ Retag and push floating tags (on release or prerelease)
        if: github.event_name == 'release' && github.event.action != 'deleted'
        run: |
          COMP=${{ matrix.component }}
          SERVICE=${{ matrix.service }}
          IMAGE="subvortex/subvortex-$COMP-$SERVICE"
          RAW_VERSION_TAG="${{ steps.taginfo.outputs.version_tag }}"
          VERSION_TAG="${RAW_VERSION_TAG#v}"
          FLOATING_TAGS="${{ steps.taginfo.outputs.floating_tags }}"
          IS_PRERELEASE=${{ github.event.release.prerelease }}
          IS_DRAFT=${{ github.event.release.draft }}
      
          echo "üì¶ Release type: prerelease=$IS_PRERELEASE, draft=$IS_DRAFT"
          echo "üè∑Ô∏è Floating tags requested: $FLOATING_TAGS"
      
          if [ "$IS_DRAFT" = "true" ]; then
            echo "‚è≠Ô∏è Skipping draft release"
            exit 0
          fi
      
          echo "üîç Getting manifest for $IMAGE:$VERSION_TAG"
          docker buildx imagetools inspect $IMAGE:$VERSION_TAG
      
          for TAG in $FLOATING_TAGS; do
            # Skip "latest" for prereleases
            if [ "$IS_PRERELEASE" = "true" ] && [ "$TAG" = "latest" ]; then
              echo "‚è≠Ô∏è Skipping 'latest' tag for prerelease"
              continue
            fi
      
            echo "üîÅ Creating manifest for $IMAGE:$TAG from $IMAGE:$VERSION_TAG"
            docker buildx imagetools create \
              --tag $IMAGE:$TAG \
              $IMAGE:$VERSION_TAG
          done

      - name: üßπ Remove floating tags (on release or prerelease delete)
        if: github.event_name == 'release' && github.event.action == 'deleted'
        run: |
          COMP=${{ matrix.component }}
          SERVICE=${{ matrix.service }}
          IMAGE="subvortex/subvortex-$COMP-$SERVICE"
          RAW_VERSION_TAG="${{ github.event.release.tag_name }}"
          VERSION_TAG="${RAW_VERSION_TAG#v}"
          FLOATING_TAGS="${{ steps.taginfo.outputs.floating_tags }}"
          USERNAME="${{ secrets.DOCKER_USERNAME }}"
          PASSWORD="${{ secrets.DOCKER_PASSWORD }}"
          REPO_NAME="subvortex-$COMP-$SERVICE"

          echo "üóëÔ∏è Release deleted: $RAW_VERSION_TAG"
          echo "üîç Attempting to delete floating tags: $FLOATING_TAGS"

          echo "üîê Requesting Docker Hub JWT token..."
          TOKEN=$(curl -s -X POST https://hub.docker.com/v2/users/login/ \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"$USERNAME\", \"password\": \"$PASSWORD\"}" | jq -r .token)

          if [ "$TOKEN" = "null" ] || [ -z "$TOKEN" ]; then
            echo "‚ùå Failed to authenticate with Docker Hub"
            exit 1
          fi

          for TAG in $FLOATING_TAGS; do
            echo "‚ùå Deleting tag: $IMAGE:$TAG"
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
              "https://hub.docker.com/v2/repositories/$USERNAME/$REPO_NAME/tags/$TAG/" \
              -H "Authorization: JWT $TOKEN")

            if [ "$RESPONSE" = "204" ]; then
              echo "‚úÖ Successfully deleted $IMAGE:$TAG"
            elif [ "$RESPONSE" = "404" ]; then
              echo "‚ö†Ô∏è Tag $TAG not found (already deleted or never pushed)"
            else
              echo "‚ùå Failed to delete tag $TAG (HTTP $RESPONSE)"
            fi
          done
        